<!DOCTYPE html>
<html>
<head>
    <title>Dots & Boxes Live</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.min.js"></script>
    <style>
        body { font-family: sans-serif; background: #f0f2f5; text-align: center; padding: 20px; }
        .container { max-width: 600px; margin: 0 auto; background: white; padding: 20px; border-radius: 12px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        .screen { display: none; }
        .active { display: block; }
        canvas { border: 2px solid #333; border-radius: 8px; margin: 10px auto; cursor: pointer; display: block;}
        button { padding: 12px 24px; font-size: 16px; margin: 5px; cursor: pointer; background: #007bff; color: white; border: none; border-radius: 6px; }
        button:hover { background: #0056b3; }
        button.secondary { background: #6c757d; }
        .status-bar { display: flex; justify-content: space-between; margin-bottom: 10px; padding: 10px; background: #e9ecef; border-radius: 6px; }
        .player-active { font-weight: bold; color: #007bff; text-decoration: underline; }
        #connStatus { font-size: 12px; color: #999; margin-bottom: 10px; }
    </style>
</head>
<body>
    <div class="container">
        <div id="connStatus">ðŸ”´ Connecting to server...</div>
        
        <div id="menuScreen" class="screen active">
            <h1>Dots & Boxes</h1>
            <button onclick="setupSingle()">Single Player (AI)</button>
            <button onclick="showMulti()">Multiplayer (Live)</button>
        </div>

        <div id="multiScreen" class="screen">
            <h2>Multiplayer</h2>
            <button onclick="createRoom()">Create Room</button>
            <br><br>
            <input type="text" id="roomCodeInput" placeholder="Enter Room Code" style="padding: 10px;">
            <button onclick="joinRoom()">Join Room</button>
            <br><br>
            <button class="secondary" onclick="showMenu()">Back</button>
        </div>

        <div id="waitScreen" class="screen">
            <h2>Waiting for player...</h2>
            <p>Room Code: <strong id="displayCode" style="font-size: 24px;"></strong></p>
            <p>Share this code with a friend.</p>
        </div>

        <div id="gameScreen" class="screen">
            <div class="status-bar">
                <span id="p1Score">P1: 0</span>
                <span id="turnIndicator">P1's Turn</span>
                <span id="p2Score">P2: 0</span>
            </div>
            <div id="timeDisplay" style="color:red; font-weight:bold;"></div>
            <canvas id="gameCanvas"></canvas>
            <button class="secondary" onclick="location.reload()">Quit</button>
        </div>
    </div>

    <script>
        // CRITICAL FOR RENDER: Force Websockets
        const socket = io({transports: ['websocket'], upgrade: false});
        
        let gameState = null;
        let myPlayer = 1; // 1 or 2
        let gameMode = 'single'; // 'single' or 'multi'
        let roomCode = null;
        let gameId = null; // for single player API
        let timerInt = null;

        // --- SOCKET EVENTS ---
        socket.on('connect', () => {
            document.getElementById('connStatus').innerText = "ðŸŸ¢ Connected to Server";
            document.getElementById('connStatus').style.color = "green";
        });
        
        socket.on('disconnect', () => {
            document.getElementById('connStatus').innerText = "ðŸ”´ Disconnected";
            document.getElementById('connStatus').style.color = "red";
        });

        socket.on('room_created', (data) => {
            roomCode = data.code;
            myPlayer = 1;
            gameState = data.state;
            document.getElementById('displayCode').innerText = roomCode;
            switchScreen('waitScreen');
        });

        socket.on('game_start', (data) => {
            roomCode = data.code;
            myPlayer = 2;
            gameState = data.state;
            startGameDisplay();
        });

        socket.on('opponent_joined', () => {
            startGameDisplay();
        });

        socket.on('update_state', (data) => {
            gameState = data.state;
            renderGame();
        });

        socket.on('opponent_left', () => {
            alert("Opponent disconnected!");
            location.reload();
        });

        socket.on('error', (data) => alert(data.msg));

        // --- LOGIC ---
        function switchScreen(id) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(id).classList.add('active');
        }

        function showMenu() { switchScreen('menuScreen'); }
        function showMulti() { switchScreen('multiScreen'); }

        // Multi Actions
        function createRoom() { socket.emit('create_room', {grid_size: 5}); }
        function joinRoom() { 
            const code = document.getElementById('roomCodeInput').value.toUpperCase();
            if(!code) return alert("Enter code");
            socket.emit('join_room', {code: code}); 
        }

        // Single Actions
        function setupSingle() {
            gameMode = 'single';
            myPlayer = 1;
            fetch('/api/start_single', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({level: 1})
            }).then(r=>r.json()).then(data => {
                gameId = data.game_id;
                gameState = data.state;
                startGameDisplay();
                startSingleTimer();
            });
        }

        function startGameDisplay() {
            switchScreen('gameScreen');
            initCanvas();
            renderGame();
        }

        function startSingleTimer() {
            if(timerInt) clearInterval(timerInt);
            timerInt = setInterval(() => {
                fetch('/api/check_time', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({game_id: gameId})
                }).then(r=>r.json()).then(d => {
                    gameState = d.state;
                    renderGame();
                    if(gameState.game_over) clearInterval(timerInt);
                });
            }, 1000);
        }

        // --- CANVAS & RENDERING ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let cellSize = 50, offset = 30;

        function initCanvas() {
            const size = Math.min(window.innerWidth - 40, 500);
            canvas.width = size;
            canvas.height = size;
            cellSize = (size - 2*offset) / gameState.grid_size;
        }

        function renderGame() {
            // Clear
            ctx.fillStyle = "white";
            ctx.fillRect(0,0,canvas.width, canvas.height);

            // Update UI
            document.getElementById('p1Score').innerText = `P1: ${gameState.scores[0]}`;
            document.getElementById('p2Score').innerText = `P2: ${gameState.scores[1]}`;
            
            let turnText = `Player ${gameState.current_player}'s Turn`;
            if (gameState.game_over) {
                turnText = gameState.winner === 0 ? "Draw!" : `Player ${gameState.winner} Wins!`;
                if(gameMode === 'single') clearInterval(timerInt);
            }
            document.getElementById('turnIndicator').innerText = turnText;
            
            if(gameState.remaining_time !== undefined) {
                document.getElementById('timeDisplay').innerText = `Time: ${gameState.remaining_time}s`;
            }

            // Draw Boxes
            for(let r=0; r<gameState.grid_size-1; r++) {
                for(let c=0; c<gameState.grid_size-1; c++) {
                    if(gameState.boxes[r][c] !== 0) {
                        ctx.fillStyle = gameState.boxes[r][c] === 1 ? "rgba(0,123,255,0.5)" : "rgba(220,53,69,0.5)";
                        ctx.fillRect(offset + c*cellSize, offset + r*cellSize, cellSize, cellSize);
                    }
                }
            }

            // Draw Lines
            ctx.lineWidth = 4;
            // Horizontal
            for(let r=0; r<gameState.grid_size; r++) {
                for(let c=0; c<gameState.grid_size-1; c++) {
                    const val = gameState.horizontal_lines[r][c];
                    ctx.strokeStyle = val === 0 ? "#eee" : (val===1 ? "blue" : "red");
                    if(val !== 0) {
                        ctx.beginPath();
                        ctx.moveTo(offset + c*cellSize, offset + r*cellSize);
                        ctx.lineTo(offset + (c+1)*cellSize, offset + r*cellSize);
                        ctx.stroke();
                    }
                }
            }
            // Vertical
            for(let r=0; r<gameState.grid_size-1; r++) {
                for(let c=0; c<gameState.grid_size; c++) {
                    const val = gameState.vertical_lines[r][c];
                    ctx.strokeStyle = val === 0 ? "#eee" : (val===1 ? "blue" : "red");
                    if(val !== 0) {
                        ctx.beginPath();
                        ctx.moveTo(offset + c*cellSize, offset + r*cellSize);
                        ctx.lineTo(offset + c*cellSize, offset + (r+1)*cellSize);
                        ctx.stroke();
                    }
                }
            }

            // Draw Dots
            ctx.fillStyle = "black";
            for(let r=0; r<gameState.grid_size; r++) {
                for(let c=0; c<gameState.grid_size; c++) {
                    ctx.beginPath();
                    ctx.arc(offset + c*cellSize, offset + r*cellSize, 4, 0, Math.PI*2);
                    ctx.fill();
                }
            }
        }

        // --- INPUT ---
        canvas.addEventListener('click', (e) => {
            if(gameState.game_over) return;
            // Strict Turn Checking
            if(gameMode === 'multi' && gameState.current_player !== myPlayer) return;
            if(gameMode === 'single' && gameState.current_player !== 1) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left - offset;
            const y = e.clientY - rect.top - offset;
            
            // Determine clicked line
            const tol = 10;
            let move = null;
            
            // Check Horizontal
            for(let r=0; r<gameState.grid_size; r++) {
                for(let c=0; c<gameState.grid_size-1; c++) {
                    let lx = c*cellSize + cellSize/2;
                    let ly = r*cellSize;
                    if(Math.abs(y - ly) < tol && x > c*cellSize && x < (c+1)*cellSize) {
                         move = {type: 'horizontal', i: r, j: c};
                    }
                }
            }
            // Check Vertical
            for(let r=0; r<gameState.grid_size-1; r++) {
                for(let c=0; c<gameState.grid_size; c++) {
                    let lx = c*cellSize;
                    let ly = r*cellSize + cellSize/2;
                    if(Math.abs(x - lx) < tol && y > r*cellSize && y < (r+1)*cellSize) {
                         move = {type: 'vertical', i: r, j: c};
                    }
                }
            }

            if(move) {
                if(gameMode === 'multi') {
                    move.code = roomCode;
                    socket.emit('multi_move', move);
                } else {
                    move.game_id = gameId;
                    fetch('/api/move', {
                        method: 'POST', 
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify(move)
                    }).then(r=>r.json()).then(d => {
                        if(d.error) return;
                        gameState = d.state;
                        renderGame();
                    });
                }
            }
        });
    </script>
</body>
</html>
