<!DOCTYPE html>
<html>
<head>
    <title>Dots & Boxes Live</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.min.js"></script>
    <style>
        body { font-family: 'Segoe UI', sans-serif; background: #f0f2f5; text-align: center; padding: 20px; }
        .container { max-width: 600px; margin: 0 auto; background: white; padding: 25px; border-radius: 12px; box-shadow: 0 8px 16px rgba(0,0,0,0.1); }
        .screen { display: none; }
        .active { display: block; }
        canvas { border: 2px solid #333; border-radius: 8px; margin: 20px auto; cursor: pointer; display: block; box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        button { padding: 12px 24px; font-size: 16px; margin: 8px; cursor: pointer; background: #667eea; color: white; border: none; border-radius: 8px; transition: transform 0.1s; }
        button:hover { background: #5a67d8; transform: scale(1.02); }
        button.secondary { background: #a0aec0; }
        .status-bar { display: flex; justify-content: space-between; margin-bottom: 15px; padding: 15px; background: #edf2f7; border-radius: 8px; font-weight: bold; font-size: 1.1em; }
        #connStatus { font-size: 12px; color: #718096; margin-bottom: 15px; }
        input { padding: 12px; border: 2px solid #e2e8f0; border-radius: 8px; font-size: 16px; width: 200px; text-align: center; }
        .level-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 10px; padding: 10px; max-height: 400px; overflow-y: auto; }
        .level-btn { background: #48bb78; padding: 10px; border-radius: 8px; cursor: pointer; color: white; border: none; }
    </style>
</head>
<body>
    <div class="container">
        <div id="connStatus">ðŸ”´ Connecting...</div>
        
        <div id="menuScreen" class="screen active">
            <h1 style="color: #667eea;">Dots & Boxes</h1>
            <button onclick="showLevels()">Single Player (AI)</button>
            <br>
            <button onclick="showMulti()">Multiplayer (Live)</button>
        </div>

        <div id="levelScreen" class="screen">
            <h2>Select Level</h2>
            <div id="levelGrid" class="level-grid"></div>
            <button class="secondary" onclick="showMenu()">Back</button>
        </div>

        <div id="multiScreen" class="screen">
            <h2>Multiplayer Lobby</h2>
            <button onclick="createRoom()">Create New Game</button>
            <div style="margin: 20px 0; font-weight: bold;">- OR -</div>
            <input type="text" id="roomCodeInput" placeholder="ENTER CODE" maxlength="5">
            <button onclick="joinRoom()">Join Game</button>
            <br><br>
            <button class="secondary" onclick="showMenu()">Back</button>
        </div>

        <div id="waitScreen" class="screen">
            <h2>Waiting for opponent...</h2>
            <p>Share this code:</p>
            <div style="background: #ebf8ff; padding: 15px; border-radius: 8px; display: inline-block;">
                <strong id="displayCode" style="font-size: 32px; color: #2b6cb0; letter-spacing: 2px;"></strong>
            </div>
            <p>Game will start when they join.</p>
        </div>

        <div id="gameScreen" class="screen">
            <div class="status-bar">
                <span id="p1Score" style="color: blue;">P1: 0</span>
                <span id="turnIndicator">...</span>
                <span id="p2Score" style="color: red;">P2: 0</span>
            </div>
            <div id="timeDisplay" style="color:#e53e3e; font-weight:bold; height: 20px;"></div>
            <canvas id="gameCanvas"></canvas>
            <button class="secondary" onclick="location.reload()">Quit Game</button>
        </div>
    </div>

    <script>
        const socket = io({transports: ['websocket'], upgrade: false});
        
        let gameState = null;
        let myPlayer = 1; 
        let gameMode = 'single';
        let roomCode = null;
        let gameId = null;
        let timerInt = null;

        // Socket Listeners
        socket.on('connect', () => {
            document.getElementById('connStatus').innerHTML = "ðŸŸ¢ Connected";
            document.getElementById('connStatus').style.color = "green";
        });
        socket.on('room_created', (data) => {
            roomCode = data.code; myPlayer = 1; gameState = data.state;
            document.getElementById('displayCode').innerText = roomCode;
            switchScreen('waitScreen');
        });
        socket.on('game_start', (data) => {
            roomCode = data.code; myPlayer = 2; gameState = data.state;
            startGameDisplay();
        });
        socket.on('opponent_joined', () => startGameDisplay());
        socket.on('update_state', (data) => { gameState = data.state; renderGame(); });
        socket.on('opponent_left', () => { alert("Opponent Left!"); location.reload(); });
        socket.on('error', (data) => alert(data.msg));

        // Navigation
        function switchScreen(id) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(id).classList.add('active');
        }
        function showMenu() { switchScreen('menuScreen'); }
        function showMulti() { switchScreen('multiScreen'); }
        function showLevels() {
            switchScreen('levelScreen');
            const grid = document.getElementById('levelGrid');
            grid.innerHTML = '';
            for(let i=1; i<=30; i++) { // Showing first 30 levels for demo
                const btn = document.createElement('button');
                btn.className = 'level-btn';
                btn.innerText = i;
                btn.onclick = () => setupSingle(i);
                grid.appendChild(btn);
            }
        }

        // Actions
        function createRoom() { socket.emit('create_room', {grid_size: 5}); }
        function joinRoom() { 
            const code = document.getElementById('roomCodeInput').value.toUpperCase();
            if(!code) return alert("Please enter a code");
            socket.emit('join_room', {code: code}); 
        }

        function setupSingle(level) {
            gameMode = 'single'; myPlayer = 1;
            fetch('/api/start_single', {
                method: 'POST', headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({level: level})
            }).then(r=>r.json()).then(data => {
                gameId = data.game_id; gameState = data.state;
                startGameDisplay();
                startSingleTimer();
            });
        }

        function startGameDisplay() {
            switchScreen('gameScreen');
            initCanvas();
            renderGame();
        }

        function startSingleTimer() {
            if(timerInt) clearInterval(timerInt);
            timerInt = setInterval(() => {
                if(!gameId || gameState.game_over) return;
                fetch('/api/check_time', {
                    method: 'POST', headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({game_id: gameId})
                }).then(r=>r.json()).then(d => {
                    if(d.error) return;
                    gameState = d.state;
                    renderGame();
                    if(gameState.game_over) clearInterval(timerInt);
                });
            }, 1000);
        }

        // Canvas Logic
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let cellSize = 50, offset = 30;

        function initCanvas() {
            const size = Math.min(window.innerWidth - 60, 500);
            canvas.width = size; canvas.height = size;
            cellSize = (size - 2*offset) / gameState.grid_size;
        }

        function renderGame() {
            if(!gameState) return;
            ctx.fillStyle = "white"; ctx.fillRect(0,0,canvas.width, canvas.height);

            // Scores & Turn
            document.getElementById('p1Score').innerText = `P1 (You): ${gameState.scores[0]}`;
            document.getElementById('p2Score').innerText = `${gameMode==='single'?'AI':'P2'}: ${gameState.scores[1]}`;
            
            let turnText = `Player ${gameState.current_player}'s Turn`;
            if(gameState.game_over) {
                turnText = gameState.winner === 0 ? "It's a Draw!" : `Player ${gameState.winner} Wins!`;
            } else if (gameMode === 'single' && gameState.current_player === 2) {
                turnText = "AI Thinking...";
            }
            document.getElementById('turnIndicator').innerText = turnText;
            
            if(gameState.remaining_time !== undefined) 
                document.getElementById('timeDisplay').innerText = `Time: ${gameState.remaining_time}s`;

            // Boxes
            for(let r=0; r<gameState.grid_size-1; r++) {
                for(let c=0; c<gameState.grid_size-1; c++) {
                    if(gameState.boxes[r][c] !== 0) {
                        ctx.fillStyle = gameState.boxes[r][c] === 1 ? "rgba(66, 153, 225, 0.5)" : "rgba(245, 101, 101, 0.5)";
                        ctx.fillRect(offset + c*cellSize, offset + r*cellSize, cellSize, cellSize);
                    }
                }
            }

            // Lines
            ctx.lineWidth = 5;
            const drawLine = (x1, y1, x2, y2, val) => {
                ctx.strokeStyle = val === 0 ? "#e2e8f0" : (val===1 ? "#4299e1" : "#f56565");
                if(val !== 0) {
                    ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
                }
            };

            for(let r=0; r<gameState.grid_size; r++) {
                for(let c=0; c<gameState.grid_size-1; c++) {
                    drawLine(offset + c*cellSize, offset + r*cellSize, offset + (c+1)*cellSize, offset + r*cellSize, gameState.horizontal_lines[r][c]);
                }
            }
            for(let r=0; r<gameState.grid_size-1; r++) {
                for(let c=0; c<gameState.grid_size; c++) {
                    drawLine(offset + c*cellSize, offset + r*cellSize, offset + c*cellSize, offset + (r+1)*cellSize, gameState.vertical_lines[r][c]);
                }
            }

            // Dots
            ctx.fillStyle = "#2d3748";
            for(let r=0; r<gameState.grid_size; r++) {
                for(let c=0; c<gameState.grid_size; c++) {
                    ctx.beginPath(); ctx.arc(offset + c*cellSize, offset + r*cellSize, 4, 0, Math.PI*2); ctx.fill();
                }
            }
        }

        canvas.addEventListener('click', (e) => {
            if(!gameState || gameState.game_over) return;
            if(gameMode === 'multi' && gameState.current_player !== myPlayer) return;
            if(gameMode === 'single' && gameState.current_player !== 1) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left - offset;
            const y = e.clientY - rect.top - offset;
            const tol = 15;
            let move = null;

            for(let r=0; r<gameState.grid_size; r++) {
                for(let c=0; c<gameState.grid_size-1; c++) {
                    let lx = c*cellSize + cellSize/2, ly = r*cellSize;
                    if(Math.abs(y - ly) < tol && x > c*cellSize && x < (c+1)*cellSize) move = {type: 'horizontal', i: r, j: c};
                }
            }
            for(let r=0; r<gameState.grid_size-1; r++) {
                for(let c=0; c<gameState.grid_size; c++) {
                    let lx = c*cellSize, ly = r*cellSize + cellSize/2;
                    if(Math.abs(x - lx) < tol && y > r*cellSize && y < (r+1)*cellSize) move = {type: 'vertical', i: r, j: c};
                }
            }

            if(move) {
                if(gameMode === 'multi') {
                    move.code = roomCode;
                    socket.emit('multi_move', move);
                } else {
                    move.game_id = gameId;
                    fetch('/api/move', {
                        method: 'POST', headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify(move)
                    }).then(r=>r.json()).then(d => {
                        if(d.error) return;
                        gameState = d.state;
                        renderGame();
                    });
                }
            }
        });
    </script>
</body>
</html>
